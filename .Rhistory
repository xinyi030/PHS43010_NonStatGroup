if (level_current %in% 2:(level_max-1)) {
if (prop_tox_cur_batch <=1/6) level_new = level_current + 1
if (prop_tox_cur_batch > 1/6 & prop_tox_cur_batch <=1/3) {
level_new = level_current
}
if (prop_tox_cur_batch > 1/3) level_new = level_current - 1
}
return(level_new)
}
single_run = function(N, n_per_cohort, target, p_true, p.tox0, dose, plt = F) {
ncohort = N/n_per_cohort
path <- tibble(patien = 1:N, levels = NA, y = NA, batches = NA)
for (i in 1:ncohort) {
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'levels']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'y'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
} # end for
# bayesian estimate using logistic model
est = crm(p.tox0, target, path[,'y'], path[, 'levels'], model = 'logistic')
mtd = dose[which.min(abs(est$ptox - target))]
if (plt) pp = plt_func(path, est, target, mtd, p_true, dose) else pp = NULL
return(list(path = path, alpha_hat = est$ptox, mtd = mtd, plt = pp))
}
plt_func = function(path, est, target, mtd, p_true, dose) {
p1 = ggplot(data.frame(path), aes(patient, levels, col = as.factor(y))) + geom_point() + theme_bw() + ylim(0,length(dose) + 1)
tbl = data.frame(x = dose, p = est$ptox, lb = est$ptoxL, ub = est$ptoxU, ptrue = p_true)
p2 = ggplot(tbl) + geom_line(aes(x, p)) + geom_point(aes(x, p), shape = 21, colour = "black", fill = "white", size = 2, stroke = 1)
p2 = p2 + geom_line(aes(x, ub), linetype = 2) + geom_point(aes(x, ub), shape = 21, colour = "black", fill = "white", size = 2, stroke = 1) + geom_line(aes(x, lb), linetype = 2) + geom_point(aes(x, lb), shape = 21, colour = "black", fill = "white", size = 2, stroke = 1)
p2 = p2 + geom_line(aes(x, ptrue), col = 'blue') + geom_point(aes(x, ptrue), shape = 22, colour = "blue", fill = "white", size = 2, stroke = 1)
p2 = p2 + geom_hline(yintercept = target, col = 'red', linetype = 2, linewidth = 0.8)
p2 = p2 + geom_vline(xintercept = mtd, col = 'green4', linetype = 3, linewidth = 1)
p2 = p2 + scale_x_continuous(breaks = dose) + labs(title = '', x = 'Dose', y = 'Probability of DLT')
p2 = p2 + theme_bw()
return(p1 + p2)
}
set.seed(1)
res = single_run_3(N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = T)
set.seed(1)
res = single_run_(N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = T)
set.seed(1)
res = single_run(N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = T)
library(tidyverse)
set.seed(1)
res = single_run(N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = T)
res
N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = T
N = 36; n_per_cohort = 3; target = 0.33; p_true = p_true_1; p.tox0 = p_true_1; dose = dose; plt = T
ncohort = N/n_per_cohort
path <- tibble(patien = 1:N, levels = NA, y = NA, batches = NA)
for (i in 1:ncohort) {
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'levels']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'y'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
} # end for
i=1
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'levels']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
View(path)
ids_cur_batch = which(path[, 'batches'] == batch_current)
ids_cur_batch
prop_tox_cur_batch
prop_tox_cur_batch = mean(path[ids_cur_batch, 'y'])
path[ids_cur_batch]
ids_cur_batch
mean(path['patient'==ids_cur_batch, 'y'])
path[ids_cur_batch, 'y']
mean(path[ids_cur_batch, 'y'])
path[ids_cur_batch, 'y']
mean(path[ids_cur_batch] %>% select(y))
path[ids_cur_batch] %>% select(y) %>% mean()
path[ids_cur_batch]
path[ids_cur_batch] %>% select(y)
path[ids_cur_batch]
filter(patien == ids_cur_batch)
path %>% filter(patien == ids_cur_batch)
mean(path %>% filter(patien == ids_cur_batch) %>% select(y) %>% mean())
path %>% filter(patien == ids_cur_batch) %>% select(y) %>% mean()
path %>% filter(patien == ids_cur_batch) %>% select(y)
patien == ids_cur_batch) %>% select(y) %>% summarize(mean())
patien == ids_cur_batch) %>% select(y) %>% summarize(mean())
path %>% filter(patien == ids_cur_batch) %>% select(y) %>% summarize(mean())
path <- data.frame(patient = 1:N, levels = NA, y = NA, batches = NA)
path[((i-1)*3+1):(i*3), 'levels']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'y'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
i=2
path[((i-1)*3+1):(i*3), 'levels']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
determine_next_dose = function(level_current, prop_tox_cur_batch, level_max) {
level_new = 1
if (level_current == 1) {
if (prop_tox_cur_batch <=1/6) level_new = 2
}
if (level_current == level_max) {
if (prop_tox_cur_batch <=1/3) {
level_new = level_max }
else level_new = level_current - 1
}
if (level_current %in% 2:(level_max-1)) {
if (prop_tox_cur_batch <=1/6) level_new = level_current + 1
if (prop_tox_cur_batch > 1/6 & prop_tox_cur_batch <=1/3) {
level_new = level_current
}
if (prop_tox_cur_batch > 1/3) level_new = level_current - 1
}
return(level_new)
}
single_run = function(N, n_per_cohort, target, p_true, p.tox0, dose, plt = F) {
ncohort = N/n_per_cohort
path <- data.frame(patient = 1:N, levels = NA, y = NA, batches = NA)
for (i in 1:ncohort) {
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'levels']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'y'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
} # end for
# bayesian estimate using logistic model
est = crm(p.tox0, target, path[,'y'], path[, 'levels'], model = 'logistic')
mtd = dose[which.min(abs(est$ptox - target))]
if (plt) pp = plt_func(path, est, target, mtd, p_true, dose) else pp = NULL
return(list(path = path, alpha_hat = est$ptox, mtd = mtd, plt = pp))
}
plt_func = function(path, est, target, mtd, p_true, dose) {
p1 = ggplot(data.frame(path), aes(patient, levels, col = as.factor(y))) + geom_point() + theme_bw() + ylim(0,length(dose) + 1)
tbl = data.frame(x = dose, p = est$ptox, lb = est$ptoxL, ub = est$ptoxU, ptrue = p_true)
p2 = ggplot(tbl) + geom_line(aes(x, p)) + geom_point(aes(x, p), shape = 21, colour = "black", fill = "white", size = 2, stroke = 1)
p2 = p2 + geom_line(aes(x, ub), linetype = 2) + geom_point(aes(x, ub), shape = 21, colour = "black", fill = "white", size = 2, stroke = 1) + geom_line(aes(x, lb), linetype = 2) + geom_point(aes(x, lb), shape = 21, colour = "black", fill = "white", size = 2, stroke = 1)
p2 = p2 + geom_line(aes(x, ptrue), col = 'blue') + geom_point(aes(x, ptrue), shape = 22, colour = "blue", fill = "white", size = 2, stroke = 1)
p2 = p2 + geom_hline(yintercept = target, col = 'red', linetype = 2, linewidth = 0.8)
p2 = p2 + geom_vline(xintercept = mtd, col = 'green4', linetype = 3, linewidth = 1)
p2 = p2 + scale_x_continuous(breaks = dose) + labs(title = '', x = 'Dose', y = 'Probability of DLT')
p2 = p2 + theme_bw()
return(p1 + p2)
}
set.seed(1)
res = single_run(N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = T)
library(dfcrm)
library(ggplot2)
library(tidyverse)
set.seed(1)
res = single_run(N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = T)
determine_next_dose = function(level_current, prop_tox_cur_batch, level_max) {
level_new = 1
if (level_current == 1) {
if (prop_tox_cur_batch <=1/6) level_new = 2
}
if (level_current == level_max) {
if (prop_tox_cur_batch <=1/3) {
level_new = level_max }
else level_new = level_current - 1
}
if (level_current %in% 2:(level_max-1)) {
if (prop_tox_cur_batch <=1/6) level_new = level_current + 1
if (prop_tox_cur_batch > 1/6 & prop_tox_cur_batch <=1/3) {
level_new = level_current
}
if (prop_tox_cur_batch > 1/3) level_new = level_current - 1
}
return(level_new)
}
single_run = function(N, n_per_cohort, target, p_true, p.tox0, dose, plt = F) {
ncohort = N/n_per_cohort
path <- data.frame(patient = 1:N, levels = NA, y = NA, batches = NA)
for (i in 1:ncohort) {
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'levels']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'y'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
} # end for
# bayesian estimate using logistic model
est = crm(p.tox0, target, path[,'y'], path[, 'levels'], model = 'logistic')
mtd = dose[which.min(abs(est$ptox - target))]
if (plt) pp = plt_func(path, est, target, mtd, p_true, dose) else pp = NULL
return(list(path = path, alpha_hat = est$ptox, mtd = mtd, plt = pp))
}
# plt_func = function(path, est, target, mtd, p_true, dose) {
# p1 = ggplot(data.frame(path), aes(patient, levels, col = as.factor(y))) + geom_point() + theme_bw() + ylim(0,length(dose) + 1)
# tbl = data.frame(x = dose, p = est$ptox, lb = est$ptoxL, ub = est$ptoxU, ptrue = p_true)
# p2 = ggplot(tbl) + geom_line(aes(x, p)) + geom_point(aes(x, p), shape = 21, colour = "black", fill = "white", size = 2, stroke = 1)
# p2 = p2 + geom_line(aes(x, ub), linetype = 2) + geom_point(aes(x, ub), shape = 21, colour = "black", fill = "white", size = 2, stroke = 1) + geom_line(aes(x, lb), linetype = 2) + geom_point(aes(x, lb), shape = 21, colour = "black", fill = "white", size = 2, stroke = 1)
# p2 = p2 + geom_line(aes(x, ptrue), col = 'blue') + geom_point(aes(x, ptrue), shape = 22, colour = "blue", fill = "white", size = 2, stroke = 1)
# p2 = p2 + geom_hline(yintercept = target, col = 'red', linetype = 2, linewidth = 0.8)
# p2 = p2 + geom_vline(xintercept = mtd, col = 'green4', linetype = 3, linewidth = 1)
# p2 = p2 + scale_x_continuous(breaks = dose) + labs(title = '', x = 'Dose', y = 'Probability of DLT')
# p2 = p2 + theme_bw()
# return(p1 + p2)
}
res = single_run(N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = F)
res
determine_next_dose = function(level_current, prop_tox_cur_batch, level_max) {
level_new = 1
if (level_current == 1) {
if (prop_tox_cur_batch <=1/6) level_new = 2
}
if (level_current == level_max) {
if (prop_tox_cur_batch <=1/3) {
level_new = level_max }
else level_new = level_current - 1
}
if (level_current %in% 2:(level_max-1)) {
if (prop_tox_cur_batch <=1/6) level_new = level_current + 1
if (prop_tox_cur_batch > 1/6 & prop_tox_cur_batch <=1/3) {
level_new = level_current
}
if (prop_tox_cur_batch > 1/3) level_new = level_current - 1
}
return(level_new)
}
single_run = function(N, n_per_cohort, target, p_true, p.tox0, dose, plt = F) {
ncohort = N/n_per_cohort
path <- data.frame(patient = 1:N, levels = NA, y = NA, batches = NA)
for (i in 1:ncohort) {
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'levels']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'y'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
} # end for
# bayesian estimate using logistic model
est = crm(p.tox0, target, path[,'y'], path[, 'levels'], model = 'logistic')
mtd = dose[which.min(abs(est$ptox - target))]
if (plt) pp = plt_func(path, est, target, mtd, p_true, dose) else pp = NULL
return(list(path, est, target, mtd, p_true, dose))
}
set.seed(1)
res = single_run(N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = F)
res
?crm
single_run = function(N, n_per_cohort, target, p_true, p.tox0, dose, plt = F) {
ncohort = N/n_per_cohort
path <- data.frame(patient = 1:N, levels = NA, y = NA, batches = NA)
for (i in 1:ncohort) {
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'levels']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'y'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
} # end for
# bayesian estimate using logistic model
est = crm(p.tox0, target, path[,'y'], path[, 'levels'], model = 'logistic2')
mtd = dose[which.min(abs(est$ptox - target))]
if (plt) pp = plt_func(path, est, target, mtd, p_true, dose) else pp = NULL
return(list(path = path, est = est, target = target, mtd = mtd, p_true = p_true,
dose = dose))
}
set.seed(1)
res = single_run(N = 36, n_per_cohort = 3, target = 0.33, p_true = p_true_1, p.tox0 = p_true_1, dose = dose, plt = F)
library(ggplot2)
library(bcrm)
y = c(0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1)
skeleton <- c(0.05, 0.10, 0.15, 0.33, 0.50)
dose <- c(0.5, 1, 3, 5, 6)
#x = c(rep(d[1], 3), rep(d[3], 3), rep(d[4], 12))
prior_tox = c(rep(skeleton[1], 3), rep(skeleton[3], 3), rep(skeleton[4], 12))
data = data.frame(patient = 1:18, dose = c(rep(1, 3), rep(3, 3), rep(4, 12)), tox = y)
target_tox = 0.33
logit_bcrm <- bcrm(stop=list(nmax=18), data=data, p.tox0=skeleton, dose = dose,
ff="logit1", prior.alpha=list(1, 1, 1), target.tox=target_tox,
constrain=F, sdose.calculate="median", pointest="mean")
print(logit_bcrm)
logit_bcrm$sdose
logit_bcrm$pointest
logit_bcrm$target.tox
logit_bcrm$tox.cutpoints
View(logit_bcrm)
logit_bcrm$ndose
?bcrm
bcrm
data = data.frame(patient = 1:18, dose = c(rep(1, 3), rep(3, 3), rep(4, 12)), tox = y)
View(data)
est <- bcrm(stop=list(nmax=18), data=path, dose = dose,
ff="logit1", prior.alpha=list(1, 1, 1), target.tox=target,
constrain=F, sdose.calculate="median", pointest="mean")
knitr::opts_chunk$set(echo = TRUE)
est <- bcrm(stop=list(nmax=18), data=path, sdose = dose,
ff="logit1", prior.alpha=list(1, 1, 1), target.tox=target,
constrain=F, sdose.calculate="median", pointest="mean")
View(path)
path <- data.frame(patient = 1:N, dose = NA, tox = NA, batches = NA)
for (i in 1:ncohort) {
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'dose']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'y'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'y'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
} # end for
for (i in 1:ncohort) {
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'dose']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'tox'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'tox'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
} # end for
path <- data.frame(patient = 1:N, dose = NA, tox = NA, batches = NA)
for (i in 1:ncohort) {
if (i == 1) {
level_current = 1
batch_current = 1
}
path[((i-1)*3+1):(i*3), 'dose']  = level_current
path[((i-1)*3+1):(i*3), 'batches'] = batch_current
path[((i-1)*3+1):(i*3), 'tox'] = rbinom(n_per_cohort, 1, p_true[level_current])
ids_cur_batch = which(path[, 'batches'] == batch_current)
prop_tox_cur_batch = mean(path[ids_cur_batch, 'tox'])
level_update = determine_next_dose(level_current, prop_tox_cur_batch,
length(p_true))
if (level_update != level_current) {
batch_current = batch_current + 1
level_current = level_update}
} # end for
View(path)
est <- bcrm(stop=list(nmax=18), data=path, sdose = dose,
ff="logit1", prior.alpha=list(1, 1, 1), target.tox=target,
constrain=F, sdose.calculate="median", pointest="mean")
View(est)
print(est)
View(path)
est <- bcrm(stop=list(nmax=18), data=path, sdose = dose,
ff="logit2", prior.alpha=list(4, c(-3, 0), c(1, 1)), target.tox=target,
constrain=F, sdose.calculate="median", pointest="mean")
rbind(c(0.84^2, 0.134), c(0.134, 0.80^2))
est <- bcrm(stop=list(nmax=18), data=path, sdose = dose,
ff="logit2", prior.alpha=list(4, c(-3, 0), rbind(c(1, 0), c(0, 1))),
target.tox=target, constrain=F, sdose.calculate="median",
pointest="mean")
est$ndose
est$sdose
View(est)
est$ndose
est <- bcrm(stop=list(nmax=18), data=path, sdose = dose,
ff="logit2", prior.alpha=list(4, c(0, 0), rbind(c(1, 0), c(0, 1))),
target.tox=target, constrain=F, sdose.calculate="median",
pointest="mean")
est$ndose
est$notox
est$tox
est$prior.alpha
mcmc_samples <- Posterior.rjags(tox = est$tox, notox = est$notox,
sdose = est$sdose, ff = "logit2",
prior.alpha = est$prior.alpha,
burnin.itr = 2000, production.itr = 2000)
mcmc_samples <- Posterior.rjags(tox = est$tox, notox = est$notox,
sdose = est$sdose, ff = "logit2",
prior.alpha = est$prior.alpha,
burnin.itr = 2000, production.itr = 2000)
mcmc_samples
mcmc_post_params <- Posterior.rjags(tox = est$tox, notox = est$notox,
sdose = est$sdose, ff = "logit2",
prior.alpha = est$prior.alpha,
burnin.itr = 2000, production.itr = 2000)
alpha_post_mean<- mean(mcmc_post_params[,1])
beta_post_mean <- mean(mcmc_post_params[,2])
tox_post <- logit2(est$sdose, alpha_post_mean, beta_post_mean)
tox_post <- (exp(log(alpha_post_mean)+beta_post_mean*est$sdose)/
(1+exp(log(alpha_post_mean)+beta_post_mean*est$sdose)))
selector <- (tox_post - target)*(tox_post-target >=0 )
selector
tox_post
tox_post[4] = 0.2
selector <- (tox_post - target)*(tox_post-target >=0 )
selector
selector[selector==0]
selector[selector==0] <-  1
selector
mtd <- dose[which.min((tox_post - target))]
mtd
dose
tox_post - target
selector <- which.min(abs(tox_post - target))
selector
dose
est
tox_post
install.packages("HDInterval")
library(HDInterval)
library(HDInterval)
mcmc_post_params[,2]
tox_post_all <- (exp(log(mcmc_post_params[,1])+mcmc_post_params[,2]*est$sdose)/
(1+exp(log(mcmc_post_params[,1])+mcmc_post_params[,2]*est$sdose)))
dim(tox_post_all)
length(tox_post_all)
beta_post_mean*est$sdose
data.frame
beta_post_mean*est$sdose
s = est$sdose[1]
tox_post_all <- (exp(log(mcmc_post_params[,1])+mcmc_post_params[,2]*s)/
(1+exp(log(mcmc_post_params[,1])+mcmc_post_params[,2]*s)))
length(tox_post_all )
hdin <- HDInterval(tox_post_all, prob = 0.95)
hdi <- hdi(tox_post_all, prob = 0.95)
hdi
hdi[1]
tox_post
lb <- rep(0, 5)
ub <- rep(0, 5)
for (i in length(est$sdose)){
s <-  est$sdose[i]
tox_post_all <- (exp(log(mcmc_post_params[,1])+mcmc_post_params[,2]*s)/
(1+exp(log(mcmc_post_params[,1])+mcmc_post_params[,2]*s)))
hdi <- hdi(tox_post_all, prob = 0.95)
lb[i] = hdi[1]
ub[i] = hdi[2]
}
lb
ub
tox_post
s
est$sdose
est$dose
est
lb
for (i in 1:length(est$sdose)){
s <-  est$sdose[i]
tox_post_all <- (exp(log(mcmc_post_params[,1])+mcmc_post_params[,2]*s)/
(1+exp(log(mcmc_post_params[,1])+mcmc_post_params[,2]*s)))
hdi <- hdi(tox_post_all, prob = 0.95)
lb[i] = hdi[1]
ub[i] = hdi[2]
}
lb
ub
